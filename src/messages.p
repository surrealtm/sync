/* Below this are the structures that define the messages that this application uses. They are used to share
 * and synchronize data between the different endpoints, and therefore need to be identical on all of them. */

MESSAGE_ID_TYPE :: u32;

Create_File_Message :: struct {
    file_id:   s64;
    file_size: u64;
    file_path: string;
}


/* Below this is the boilerplate code for serialization code for the above defined messages. It implements
 * writing messages to packets and reading messages back from packets, as well as code to automatically
 * detect all messages in a packet and call the appropriate callback on them. 
 * All of the code below should in the future be auto-generated by some source generator, ideally from
 * inside the meta-program, once that is powerful enough to handle it. Until then, this will be updated
 * manually. */

Message_Callbacks :: struct {
    user_pointer: *void;
    on_create_file: (*void, *Create_File_Message);
}

CREATE_FILE_MESSAGE_ID: MESSAGE_ID_TYPE : 1;

packet_write_create_file_message :: (packet: *Packet, message: *Create_File_Message) {
    packet_write(packet, CREATE_FILE_MESSAGE_ID);
    packet_write(packet, message.file_id);
    packet_write(packet, message.file_size);
    packet_write_string(packet, message.file_path);
}

send_create_file_message :: (connection: *Virtual_Connection, message: Create_File_Message) {
    packet: Packet;
    packet_write_create_file_message(*packet, *message);
    send_packet(connection, *packet);
}

packet_read_create_file_message :: (packet: *Packet) -> Create_File_Message {
    message: Create_File_Message = ---;
    message.file_id   = packet_read(packet, s64);
    message.file_size = packet_read(packet, u64);
    message.file_path = packet_read_string_view(packet);
    return message;
}


parse_all_packet_messages :: (packet: *Packet, callbacks: *Message_Callbacks) {
    packet_body_size := packet.header.packet_size - PACKET_HEADER_SIZE;

    while packet.body_offset < packet_body_size {
        message_id := packet_read(packet, MESSAGE_ID_TYPE);

        switch message_id {
        case CREATE_FILE_MESSAGE_ID;
            message: Create_File_Message = packet_read_create_file_message(packet);
            callbacks.on_create_file(callbacks.user_pointer, *message);

        case;
            print("Invalid message id, cannot parse: %\n", message_id);
            packet.body_offset = packet_body_size; // Skip to the end of the packet so that the outer while loop exits
        }
    }
}
