/* Below this are the structures that define the messages that this application uses. They are used to share
 * and synchronize data between the different endpoints, and therefore need to be identical on all of them. */

File_Info_Message :: struct {
    file_id:   File_Id;
    file_size: u64;
    file_path: string;
    truncate_file: bool; // This flag indicates whether or not the receiver should truncate the local file. The file should be truncated if data will follow this message, e.g. when the file was actually requested to local. If this is just a synchronisation of the file registries, then the actual file system should not be touched, and this flag is set to false
}

File_Content_Message :: struct {
    file_id: File_Id; // The file id of the registry, used to identify what file this data is for. This avoids having to send platform-dependent file paths over the network
    file_offset: u64; // The byte-offset position inside the file where the data should be inserted. Used to detect gaps in the sent data, though that should theoretically never occur
    file_data: string; // The actual bytes of the file. The array is sized to exactly fit the number of bytes sent in this message
}

File_Request_Message :: struct {
    // In the future this could maybe also allow requesting by id for less overhead, less typing required by
    // the user as well as less ambigouity, though that should probably never happen with complete file
    // paths anyway?
    file_path: string;
}

File_Registration_Message :: struct {
    // When a client wants to push a local file, they must first register the file on the server to obtain
    // an id for them, since the file transfer as well as the registries depend on that.
    file_path: string;
    file_size: u64;
}

Sync_Request_Message :: struct {
    unused: u64; // The compiler currently does not like empty structs, so just throw this in here
}


send_file_content :: (connection: *Virtual_Connection, registry: *File_Registry, file: *File_Entry) {
    local_file_path := get_registry_file_path(registry, file.file_path);

    content, success := read_file(local_file_path);
    defer free_file_data(content);
    assert(success, "Could not open the local file for transfer");
    
    content_offset := 0;
    batch_size := PACKET_BODY_SIZE - 24; // 24 Bytes are required for the file content message itself (file id, offset, and byte count)

    while content_offset < content.count {
        message_size := min(content.count - content_offset, batch_size);
        send_file_content_message(connection, .{ file.file_id, content_offset, substring_view(content, content_offset, content_offset + message_size) });
        content_offset += message_size;
    }
}

send_file :: (connection: *Virtual_Connection, registry: *File_Registry, file: *File_Entry) {
    send_file_info_message(connection, .{ file.file_id, file.file_size, file.file_path, true });
    send_file_content(connection, registry, file);
}

request_file :: (connection: *Virtual_Connection, file_path: string) {
    send_file_request_message(connection, .{ file_path } );
}

register_file :: (connection: *Virtual_Connection, file_path: string, file_size: u64) {
    send_file_registration_message(connection, .{ file_path, file_size } );
}

sync_file_registry :: (connection: *Virtual_Connection) {
    send_sync_request_message(connection, .{ 0 } );
}



/* Below this is the boilerplate code for serialization code for the above defined messages. It implements
 * writing messages to packets and reading messages back from packets, as well as code to automatically
 * detect all messages in a packet and call the appropriate callback on them. 
 * All of the code below should in the future be auto-generated by some source generator, ideally from
 * inside the meta-program, once that is powerful enough to handle it. Until then, this will be updated
 * manually. */


// Eventually, this enum should be sized to barely fit all elements, e.g. right now a u8 would suffice. Since
// enums currently do not support changing the internal bit representation, this will have to wait.
Message_Id :: enum {
    File_Info         :: 1;
    File_Content      :: 2;
    File_Request      :: 3;
    Sync_Request      :: 4;
    File_Registration :: 5;
}

Message_Callbacks :: struct {
    user_pointer:          *void;
    on_file_info:         (*void, *File_Info_Message);
    on_file_content:      (*void, *File_Content_Message);
    on_file_request:      (*void, *File_Request_Message);
    on_sync_request:      (*void, *Sync_Request_Message);
    on_file_registration: (*void, *File_Registration_Message);
}


packet_write_file_info_message :: (packet: *Packet, message: *File_Info_Message) {
    packet_write(packet, Message_Id.File_Info);
    packet_write(packet, message.file_id);
    packet_write(packet, message.file_size);
    packet_write_string(packet, message.file_path);
    packet_write(packet, message.truncate_file);
}

packet_read_file_info_message :: (packet: *Packet) -> File_Info_Message {
    message: File_Info_Message = ---;
    message.file_id   = packet_read(packet, File_Id);
    message.file_size = packet_read(packet, u64);
    message.file_path = packet_read_string_view(packet);
    message.truncate_file = packet_read(packet, bool);
    return message;
}

send_file_info_message :: (connection: *Virtual_Connection, message: File_Info_Message) {
    packet: Packet;
    packet_write_file_info_message(*packet, *message);
    send_packet(connection, *packet);
}


packet_write_file_content_message :: (packet: *Packet, message: *File_Content_Message) {
    packet_write(packet, Message_Id.File_Content);
    packet_write(packet, message.file_id);
    packet_write(packet, message.file_offset);
    packet_write_string(packet, message.file_data); // Write the data byte-wise
}

packet_read_file_content_message :: (packet: *Packet) -> File_Content_Message {
    message: File_Content_Message = ---;
    message.file_id     = packet_read(packet, File_Id);
    message.file_offset = packet_read(packet, u64);
    message.file_data   = packet_read_string_view(packet);
    return message;
}

send_file_content_message :: (connection: *Virtual_Connection, message: File_Content_Message) {
    packet: Packet;
    packet_write_file_content_message(*packet, *message);
    send_packet(connection, *packet);
}


packet_write_file_request_message :: (packet: *Packet, message: *File_Request_Message) {
    packet_write(packet, Message_Id.File_Request);
    packet_write_string(packet, message.file_path);
}

packet_read_file_request_message :: (packet: *Packet) -> File_Request_Message {
    message: File_Request_Message = ---;
    message.file_path = packet_read_string_view(packet);
    return message;
}

send_file_request_message :: (connection: *Virtual_Connection, message: File_Request_Message) {
    packet: Packet;
    packet_write_file_request_message(*packet, *message);
    send_packet(connection, *packet);
}


packet_write_file_registration_message :: (packet: *Packet, message: *File_Registration_Message) {
    packet_write(packet, Message_Id.File_Registration);
    packet_write_string(packet, message.file_path);
    packet_write(packet, message.file_size);
}

packet_read_file_registration_message :: (packet: *Packet) -> File_Registration_Message {
    message: File_Registration_Message = ---;
    message.file_path = packet_read_string_view(packet);
    message.file_size = packet_read(packet, u64);
    return message;
}

send_file_registration_message :: (connection: *Virtual_Connection, message: File_Registration_Message) {
    packet: Packet;
    packet_write_file_registration_message(*packet, *message);
    send_packet(connection, *packet);
}


packet_write_sync_request_message :: (packet: *Packet, message: *Sync_Request_Message) {
    packet_write(packet, Message_Id.Sync_Request);
}

packet_read_sync_request_message :: (packet: *Packet) -> Sync_Request_Message {
    message: Sync_Request_Message = ---;
    return message;
}

send_sync_request_message :: (connection: *Virtual_Connection, message: Sync_Request_Message) {
    packet: Packet;
    packet_write_sync_request_message(*packet, *message);
    send_packet(connection, *packet);
}


parse_all_packet_messages :: (packet: *Packet, callbacks: *Message_Callbacks) {
    packet_body_size := packet.header.packet_size - PACKET_HEADER_SIZE;
    
    while packet.body_offset < packet_body_size {
        message_id: Message_Id = packet_read(packet, Message_Id);

        switch message_id {
        case .File_Info;
            message: File_Info_Message = packet_read_file_info_message(packet);
            callbacks.on_file_info(callbacks.user_pointer, *message);

        case .File_Content;
            message: File_Content_Message = packet_read_file_content_message(packet);
            callbacks.on_file_content(callbacks.user_pointer, *message);

        case .File_Request;
            message: File_Request_Message = packet_read_file_request_message(packet);
            callbacks.on_file_request(callbacks.user_pointer, *message);

        case .File_Registration;
            message: File_Registration_Message = packet_read_file_registration_message(packet);
            callbacks.on_file_registration(callbacks.user_pointer, *message);

        case .Sync_Request;
            message: Sync_Request_Message = packet_read_sync_request_message(packet);
            callbacks.on_sync_request(callbacks.user_pointer, *message);
            
        case;
            print("Invalid message id, no messages defined with id: %\n", cast(s64) message_id);
            packet.body_offset = packet_body_size; // Skip to the end of the packet so that the outer while loop exits
        }
    }
}
