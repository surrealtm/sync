/* Below this are the structures that define the messages that this application uses. They are used to share
 * and synchronize data between the different endpoints, and therefore need to be identical on all of them. */

Create_File_Message :: struct {
    file_id:   File_Id;
    file_size: u64;
    file_path: string;
}

File_Content_Message :: struct {
    file_id: File_Id; // The file id of the registry, used to identify what file this data is for. This avoids having to send platform-dependent file paths over the network
    file_offset: u64; // The byte-offset position inside the file where the data should be inserted. Used to detect gaps in the sent data, though that should theoretically never occur
    file_data: string; // The actual bytes of the file. The array is sized to exactly fit the number of bytes sent in this message
}

File_Request_Message :: struct {
    // In the future this could maybe also allow requesting by id for less overhead, less typing required by
    // the user as well as less ambigouity, though that should probably never happen with complete file
    // paths anyway?
    file_path: string;
}


send_file :: (connection: *Virtual_Connection, registry: *File_Registry, file: *File_Entry) {
    content, success := read_file(get_registry_file_path(registry, file.file_path));
    defer free_file_data(content);

    if !success {
        print("Failed to read local file '%' for transfer.\n", file.file_path);
        return;
    }
    
    send_create_file_message(connection, .{ file.file_id, file.file_size, file.file_path });

    content_offset := 0;
    batch_size := 1; //PACKET_BODY_SIZE - 24; // 24 Bytes are required for the file content message itself (file id, offset, and byte count)

    while content_offset < content.count {
        message_size := min(content.count - content_offset, batch_size);
        send_file_content_message(connection, .{ file.file_id, content_offset, substring_view(content, content_offset, content_offset + message_size) });
        content_offset += message_size;
    }    
}

request_file :: (connection: *Virtual_Connection, file_path: string) {
    send_file_request_message(connection, .{ file_path } );
}



/* Below this is the boilerplate code for serialization code for the above defined messages. It implements
 * writing messages to packets and reading messages back from packets, as well as code to automatically
 * detect all messages in a packet and call the appropriate callback on them. 
 * All of the code below should in the future be auto-generated by some source generator, ideally from
 * inside the meta-program, once that is powerful enough to handle it. Until then, this will be updated
 * manually. */


// Eventually, this enum should be sized to barely fit all elements, e.g. right now a u8 would suffice. Since
// enums currently do not support changing the internal bit representation, this will have to wait.
Message_Id :: enum {
    Create_File  :: 1; // @Cleanup rename to File_Create or something?
    File_Content :: 2;
    File_Request :: 3;
}

Message_Callbacks :: struct {
    user_pointer:     *void;
    on_create_file:  (*void, *Create_File_Message);
    on_file_content: (*void, *File_Content_Message);
    on_file_request: (*void, *File_Request_Message);
}


packet_write_create_file_message :: (packet: *Packet, message: *Create_File_Message) {
    packet_write(packet, Message_Id.Create_File);
    packet_write(packet, message.file_id);
    packet_write(packet, message.file_size);
    packet_write_string(packet, message.file_path);
}

packet_read_create_file_message :: (packet: *Packet) -> Create_File_Message {
    message: Create_File_Message = ---;
    message.file_id   = packet_read(packet, File_Id);
    message.file_size = packet_read(packet, u64);
    message.file_path = packet_read_string_view(packet);
    return message;
}

send_create_file_message :: (connection: *Virtual_Connection, message: Create_File_Message) {
    packet: Packet;
    packet_write_create_file_message(*packet, *message);
    send_packet(connection, *packet);
}


packet_write_file_content_message :: (packet: *Packet, message: *File_Content_Message) {
    packet_write(packet, Message_Id.File_Content);
    packet_write(packet, message.file_id);
    packet_write(packet, message.file_offset);
    packet_write_string(packet, message.file_data); // Write the data byte-wise
}

packet_read_file_content_message :: (packet: *Packet) -> File_Content_Message {
    message: File_Content_Message = ---;
    message.file_id     = packet_read(packet, File_Id);
    message.file_offset = packet_read(packet, u64);
    message.file_data   = packet_read_string_view(packet);
    return message;
}

send_file_content_message :: (connection: *Virtual_Connection, message: File_Content_Message) {
    packet: Packet;
    packet_write_file_content_message(*packet, *message);
    send_packet(connection, *packet);
}


packet_write_file_request_message :: (packet: *Packet, message: *File_Request_Message) {
    packet_write(packet, Message_Id.File_Request);
    packet_write_string(packet, message.file_path);
}

packet_read_file_request_message :: (packet: *Packet) -> File_Request_Message {
    message: File_Request_Message = ---;
    message.file_path = packet_read_string_view(packet);
    return message;
}

send_file_request_message :: (connection: *Virtual_Connection, message: File_Request_Message) {
    packet: Packet;
    packet_write_file_request_message(*packet, *message);
    send_packet(connection, *packet);
}


parse_all_packet_messages :: (packet: *Packet, callbacks: *Message_Callbacks) {
    packet_body_size := packet.header.packet_size - PACKET_HEADER_SIZE;
    
    while packet.body_offset < packet_body_size {
        message_id: Message_Id = packet_read(packet, Message_Id);

        switch message_id {
        case .Create_File;
            message: Create_File_Message = packet_read_create_file_message(packet);
            callbacks.on_create_file(callbacks.user_pointer, *message);

        case .File_Content;
            message: File_Content_Message = packet_read_file_content_message(packet);
            callbacks.on_file_content(callbacks.user_pointer, *message);

        case .File_Request;
            message: File_Request_Message = packet_read_file_request_message(packet);
            callbacks.on_file_request(callbacks.user_pointer, *message);
            
        case;
            print("Invalid message id, no messages defined with id: %\n", cast(s64) message_id);
            packet.body_offset = packet_body_size; // Skip to the end of the packet so that the outer while loop exits
        }
    }
}
